# Codex YAML – Kliens írási útvonalak átállítása + Rules finomhangolás

# Megjegyzés: Ez a YAML a „Firestore refaktor – Kliens írási útvonalak átállítása + Rules finomhangolás (terv)” vászonhoz készült kiegészítés.

steps:

* name: Firestore Rules – root tickets create tiltása + users/{uid}/tickets engedélyezése
  description: |
  A kliens mostantól a `users/{uid}/tickets/{ticketId}` alá ír. A gyökér `tickets/*` kollekcióra a create letiltása, majd a users‑alatti tickets engedélyezése ownerre.
  outputs:

  * type: diff
    path: cloud\_functions/firestore.rules
    content: |
    \--- a/cloud\_functions/firestore.rules
    +++ b/cloud\_functions/firestore.rules
    @@
    match /tickets/{ticketId} {
* ```
         allow create: if signedIn()
  ```
* ```
           && request.resource.data.userId == request.auth.uid
  ```
* ```
           && request.resource.data.keys().hasOnly(['id','userI...','totalOdd','potentialWin','createdAt','updatedAt','status']);
  ```

- ```
         // V3: új jegyek nem a gyökérben jönnek létre
  ```
- ```
         allow create: if false;
         allow read: if signedIn();
         allow update, delete: if false;
       }
  ```
-
- ```
       /*  ─── Users tickets subcollection (új írási útvonal) ───  */
  ```
- ```
       match /users/{userId}/tickets/{ticketId} {
  ```
- ```
         allow create: if isOwner(userId) && request.resource.data.userId == userId;
  ```
- ```
         allow read: if isOwner(userId);
  ```
- ```
         allow update, delete: if false;
  ```
- ```
       }
  ```

  * name: MyTickets – stream átterelése users/{uid}/tickets alá
    description: |
    A gyökér `tickets` helyett a user saját ágáról olvasunk; a `where userId == uid` feltétel felesleges, töröljük.
    outputs:

    * type: diff
      path: lib/screens/my\_tickets\_screen.dart
      content: |
      \--- a/lib/screens/my\_tickets\_screen.dart
      +++ b/lib/screens/my\_tickets\_screen.dart
      @@

* return FirebaseFirestore.instance
* ```
   .collection('tickets')
  ```
* ```
   .where('userId', isEqualTo: uid)
  ```

- return FirebaseFirestore.instance
- ```
   .collection('users')
  ```
- ```
   .doc(uid)
  ```
- ```
   .collection('tickets')
   .orderBy('createdAt', descending: true)
   .snapshots()
   .map((snap) => snap.docs.map((d) => Ticket.fromJson(d.data())).toList());
  ```

  * name: CoinService – kliens wallet írás kivezetése (debit/credit)
    description: |
    A `debitCoin` és `creditCoin` többé nem módosítja lokál tranzakcióban a walletet; kizárólag a `coin_trx` CF végzi a pénzmozgást.
    outputs:

    * type: diff
      path: lib/services/coin\_service.dart
      content: |
      \--- a/lib/services/coin\_service.dart
      +++ b/lib/services/coin\_service.dart
      @@
      Future<void> debitCoin({
      required int amount,
      required String reason,
      required String transactionId,
      }) async {

* ```
         await _wrapper.run((txn) async {
  ```
* ```
           final uid = _fa.currentUser!.uid;
  ```
* ```
           final ref = _fs.collection('wallets').doc(uid);
  ```
* ```
           final snap = await txn.get(ref);
  ```
* ```
           final current = (snap.data()?['coins'] as int?) ?? 0;
  ```
* ```
           txn.set(ref, {'coins': current - amount}, SetOptions(merge: true));
  ```
* ```
         });
  ```

- ```
         // Client-side wallet mutation removed: handled by Cloud Function (coin_trx)
         await _callCoinTrx(
           amount: amount,
           type: 'debit',
           reason: reason,
           transactionId: transactionId,
         );
       }
      @@
       Future<void> creditCoin({
         required int amount,
         required String reason,
         required String transactionId,
       }) async {
  ```

* ```
         await _wrapper.run((txn) async {
  ```
* ```
           final uid = _fa.currentUser!.uid;
  ```
* ```
           final ref = _fs.collection('wallets').doc(uid);
  ```
* ```
           final snap = await txn.get(ref);
  ```
* ```
           final current = (snap.data()?['coins'] as int?) ?? 0;
  ```
* ```
           txn.set(ref, {'coins': current + amount}, SetOptions(merge: true));
  ```
* ```
         });
  ```

- ```
         // Client-side wallet mutation removed: handled by Cloud Function (coin_trx)
         await _callCoinTrx(
           amount: amount,
           type: 'credit',
           reason: reason,
           transactionId: transactionId,
         );
       }
  ```

  * name: CoinService – hasClaimedToday → users/{uid}/ledger lekérdezés
    description: |
    A napi bónusz ellenőrzése a per‑user `ledger` alá kerül (`source == 'daily_bonus'`, időfilter `createdAt` szerint).
    outputs:

    * type: diff
      path: lib/services/coin\_service.dart
      content: |
      \--- a/lib/services/coin\_service.dart
      +++ b/lib/services/coin\_service.dart
      @@

* final query = await db
* ```
     .collection('wallets')
  ```
* ```
     .doc(user.uid)
  ```
* ```
     .collection('coin_logs')
  ```
* ```
     .where('reason', isEqualTo: 'daily_bonus')
  ```
* ```
     .where(
  ```
* ```
       'timestamp',
  ```
* ```
       isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay),
  ```
* ```
     )
  ```
* ```
     .where('timestamp', isLessThan: Timestamp.fromDate(endOfDay))
  ```

- final query = await db
- ```
     .collection('users')
  ```
- ```
     .doc(user.uid)
  ```
- ```
     .collection('ledger')
  ```
- ```
     .where('source', isEqualTo: 'daily_bonus')
  ```
- ```
     .where(
  ```
- ```
       'createdAt',
  ```
- ```
       isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay),
  ```
- ```
     )
  ```
- ```
     .where('createdAt', isLessThan: Timestamp.fromDate(endOfDay))
     .limit(1)
     .get();
  ```

  * name: CoinService – debitAndCreateTicket: user‑ág + CF debit + kompenzáció
    description: |
    A jegy létrehozása a `users/{uid}/tickets/{ticketId}` alá történik. Lokális wallet módosítás törölve. Sikeres jegylétrehozás után `coin_trx` debit hívás (reason: `bet`, `transactionId` = ticketId). CF hiba esetén a jegy törlésre kerül.
    outputs:

    * type: diff
      path: lib/services/coin\_service.dart
      content: |
      \--- a/lib/services/coin\_service.dart
      +++ b/lib/services/coin\_service.dart
      @@
      Future<void> debitAndCreateTicket({
      required int stake,
      required Map\<String, dynamic> ticketData,
      }) async {
      final uid = \_fa.currentUser!.uid;

* final walletRef = \_fs.collection('wallets').doc(uid);
* final userRef = \_fs.collection('users').doc(uid);
* final ticketRef = \_fs.collection('tickets').doc(ticketData\['id'] as String);
*
* await \_fs.runTransaction((txn) async {
* ```
   final walletSnap = await txn.get(walletRef);
  ```
* ```
   int current;
  ```
* ```
   if (walletSnap.exists && walletSnap.data()!.containsKey('coins')) {
  ```
* ```
     current = walletSnap.data()!['coins'] as int;
  ```
* ```
   } else {
  ```
* ```
     // ➡️ fallback: read balance from users doc
  ```
* ```
     final userSnap = await txn.get(userRef);
  ```
* ```
     current = (userSnap.data()?['coins'] as int?) ?? 0;
  ```
*
* ```
     // ➡️ LAZY‑CREATE wallet doc so subsequent requests use it
  ```
* ```
     txn.set(walletRef, {
  ```
* ```
       'coins': current,
  ```
* ```
       'createdAt': FieldValue.serverTimestamp(),
  ```
* ```
     });
  ```
* ```
   }
  ```
*
* ```
   if (current < stake) {
  ```
* ```
     throw FirebaseException(
  ```
* ```
       plugin: 'coin_service',
  ```
* ```
       code: 'insufficient_coins',
  ```
* ```
       message: 'Not enough TippCoin balance.',
  ```
* ```
     );
  ```
* ```
   }
  ```
*
* ```
   txn.update(walletRef, {'coins': current - stake});
  ```
* ```
   txn.set(userRef, {'coins': current - stake}, SetOptions(merge: true));
  ```
* ```
   txn.set(ticketRef, ticketData);
  ```
* });

- final ticketId = ticketData\['id'] as String;
- final ticketRef = \_fs.doc('users/\$uid/tickets/\$ticketId');
- await ticketRef.set(ticketData);
- try {
- ```
   await _callCoinTrx(
  ```
- ```
     amount: stake,
  ```
- ```
     type: 'debit',
  ```
- ```
     reason: 'bet',
  ```
- ```
     transactionId: ticketId,
  ```
- ```
   );
  ```
- } catch (e) {
- ```
   // Kompenzáció: ha a CF debit elbukik, töröljük a létrehozott jegyet
  ```
- ```
   await ticketRef.delete();
  ```
- ```
   rethrow;
  ```
- }
  }

* name: StatsService – tickets és balance olvasási útvonalak frissítése
  description: |
  A statokhoz a jegyeket `collectionGroup('tickets')`‑ből kérdezzük, a coin egyenleg elsődleges forrása a `users/{uid}/wallet.coins` (fallback a régi `users/{uid}.coins`). A per‑user részben a jegyeket a user ágáról listázzuk.
  outputs:

  * type: diff
    path: lib/services/stats\_service.dart
    content: |
    \--- a/lib/services/stats\_service.dart
    +++ b/lib/services/stats\_service.dart
    @@
* final ticketsRef = \_db.collection('tickets');

- final ticketsRef = \_db.collectionGroup('tickets');
  @@

* ```
     final coins = (data['coins'] as int?) ?? 0;
  ```

- ```
     final walletSnap = await _db.doc('users/$uid/wallet').get();
  ```
- ```
     final coins = (walletSnap.data()?['coins'] as int?) ?? (data['coins'] as int? ?? 0);
      @@
  ```

* final coins = (userData\['coins'] as int?) ?? 0;

- final walletSnap = await \_db.doc('users/\$uid/wallet').get();
- final coins = (walletSnap.data()?\['coins'] as int?) ?? (userData\['coins'] as int? ?? 0);
  @@

* final ticketSnap = await \_db
* ```
     .collection('tickets')
  ```
* ```
     .where('userId', isEqualTo: uid)
  ```
* ```
     .get();
  ```

- final ticketSnap = await \_db
- ```
     .collection('users')
  ```
- ```
     .doc(uid)
  ```
- ```
     .collection('tickets')
  ```
- ```
     .get();
  ```

  * name: Build & Test
    description: |
    Statikus ellenőrzések és unit/e2e futtatás.
    outputs:

    * type: command
      content: |
      flutter analyze
      flutter test
      cd cloud\_functions && npm ci && npm test

  * name: Kiegészítő információ
    description: |
    A lépések szakmai hátterét és döntési elveit a „Firestore refaktor – Kliens írási útvonalak átállítása + Rules finomhangolás (terv)” vászon tartalmazza.
    outputs:

    * type: note
      content: Ez a YAML a fenti vászon kiegészítője; a pontos indoklás és QA-szcenáriók ott találhatók.
