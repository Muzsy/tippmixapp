# Codex Canvas Yaml – /v3/odds URL-építés Uri-val, 429-retry, no-cache-on-null
# Pontos diffek a most feltöltött zipben lévő kódhoz igazítva.

steps:
  - name: Odds URL összeállítás Uri-val + debug log + 429 retry
    inputs:
      - file: tippmixapp-main/lib/services/api_football_service.dart
    outputs:
      - type: patch
        file: tippmixapp-main/lib/services/api_football_service.dart
        content: |
          --- a/tippmixapp-main/lib/services/api_football_service.dart
          +++ b/tippmixapp-main/lib/services/api_football_service.dart
          @@
           Future<Map<String, dynamic>> getOddsForFixture(
               String fixtureId, {
                 int? season,
                 bool includeBet1 = true,
               }) async {
             final apiKey = dotenv.env['API_FOOTBALL_KEY'];
             if (apiKey == null || apiKey.isEmpty) {
               throw Exception('Missing API_FOOTBALL_KEY');
             }
-            final seasonPart = season != null ? '&season=$season' : '';
-            final betPart = includeBet1 ? '&bet=1' : '';
-            final url = '$_baseUrl/odds?fixture=$fixtureId$seasonPart$betPart';
-
-            Future<http.Response> _attempt() => _client
-                .get(Uri.parse(url), headers: {'x-apisports-key': apiKey})
-                .timeout(const Duration(seconds: 10));
-
-            http.Response res;
-            try {
-              res = await _attempt();
-            } catch (_) {
-              await Future.delayed(const Duration(milliseconds: 200));
-              res = await _attempt();
-            }
-            if (res.statusCode >= 200 && res.statusCode < 300) {
-              final body = jsonDecode(res.body) as Map<String, dynamic>;
-              return body;
-            }
-            return {};
+            // Uri-alapú query összerakás – elkerüli a 'season=2025bet=1' összefolyást
+            final qp = <String, String>{
+              'fixture': fixtureId,
+              if (season != null) 'season': '$season',
+              if (includeBet1) 'bet': '1',
+            };
+            final uri = Uri.parse('$_baseUrl/odds').replace(queryParameters: qp);
+
+            final headers = <String, String>{'x-apisports-key': apiKey};
+            assert(() {
+              headers['X-Client'] = 'tippmixapp-mobile';
+              // ignore: avoid_print
+              print('[odds] GET ' + uri.toString());
+              return true;
+            }());
+
+            Future<http.Response> _attempt() => _client
+                .get(uri, headers: headers)
+                .timeout(const Duration(seconds: 10));
+
+            http.Response res;
+            try {
+              res = await _attempt();
+            } catch (_) {
+              await Future.delayed(const Duration(milliseconds: 200));
+              res = await _attempt();
+            }
+            // 429 eset – rövid backoff és 1× retry
+            if (res.statusCode == 429) {
+              await Future.delayed(const Duration(milliseconds: 200));
+              res = await _attempt();
+            }
+            if (res.statusCode >= 200 && res.statusCode < 300) {
+              final body = jsonDecode(res.body) as Map<String, dynamic>;
+              return body;
+            }
+            return {};
           }
  - name: H2H cache – csak sikeres eredményt cache-eljünk (no-cache-on-null)
    inputs:
      - file: tippmixapp-main/lib/services/api_football_service.dart
    outputs:
      - type: patch
        file: tippmixapp-main/lib/services/api_football_service.dart
        content: |
          --- a/tippmixapp-main/lib/services/api_football_service.dart
          +++ b/tippmixapp-main/lib/services/api_football_service.dart
          @@
           Future<OddsMarket?> getH2HForFixture(int fixtureId, {int? season}) {
             if (fixtureId <= 0) return Future.value(null);
             final now = DateTime.now();
             final cached = _h2hCache[fixtureId];
             if (cached != null && now.isBefore(cached.until)) {
               return cached.f;
             }
-            final future = _fetchH2HForFixture(fixtureId, season: season);
-            _h2hCache[fixtureId] = _CachedH2H(future, now.add(_h2hTtl));
-            return future;
+            final future = _fetchH2HForFixture(fixtureId, season: season).then((value) {
+              if (value != null) {
+                _h2hCache[fixtureId] = _CachedH2H(
+                  Future<OddsMarket?>.value(value),
+                  DateTime.now().add(_h2hTtl),
+                );
+              } else {
+                _h2hCache.remove(fixtureId);
+              }
+              return value;
+            }, onError: (e) {
+              _h2hCache.remove(fixtureId);
+              throw e;
+            });
+            return future;
           }

  - name: Statikus analízis és tesztek
    outputs:
      - type: run
        command: flutter analyze --no-fatal-infos lib test
      - type: run
        command: flutter test
