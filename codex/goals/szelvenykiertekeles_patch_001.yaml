# TippmixApp – Codex Patch Goal
# Hivatkozás a kiegészítő magyarázatra: lásd a vásznat „Szelvénykiértékelés – Patch sorozat 001 (konkrét javítások és diff-ek)”
version: 1
kind: patch-series
metadata:
  id: szelvenykiertekeles_patch_001
  title: "Szelvénykiértékelés – ApiFootball feloldás, H2H normalizálás, void kezelés"
  related_canvas: "Szelvénykiértékelés – Patch sorozat 001 (konkrét javítások és diff-ek)"
  repo_root: tippmixapp-main
steps:
  - id: apifootball_fixture_lookup
    description: "ApiFootball – findFixtureIdByMeta implementálása (eddig return null volt)"
    apply:
      - path: cloud_functions/src/services/ApiFootballResultProvider.ts
        diff: |
          --- a/cloud_functions/src/services/ApiFootballResultProvider.ts
          +++ b/cloud_functions/src/services/ApiFootballResultProvider.ts
          @@
          -export async function findFixtureIdByMeta(params: { eventName: string; startTime: string }): Promise<{ id: number } | null> {
          -  const [home, away] = params.eventName.split(' - ').map(s => s?.trim()).filter(Boolean);
          -  if (!home || !away) return null;
          -  const date = params.startTime.slice(0, 10); // YYYY-MM-DD
          -  // Példa: GET /fixtures?date=YYYY-MM-DD&team=... (vagy search endpoint a bevezetett logika szerint)
          -  // Itt a projekt meglévő fetch utilját használjuk, és a válaszból a (home,away,start) egyezést keressük.
          -  // A pontos implementáció a szolgáltató végpontjaihoz igazodik.
          -  return null; // helykitöltő: a tényleges végpont-hívás a projekt utils szerint kerül megírásra
          -}
          +export async function findFixtureIdByMeta(params: { eventName: string; startTime: string }): Promise<{ id: number } | null> {
          +  const [home, away] = (params.eventName || '').split(' - ').map(s => s?.trim()).filter(Boolean);
          +  if (!home || !away) return null;
          +  const date = (params.startTime || '').slice(0, 10); // YYYY-MM-DD
          +  const apiKey = (process.env.API_FOOTBALL_KEY || functions.config().apifootball?.key) ?? '';
          +  if (!apiKey || !date) return null;
          +
          +  const base = 'https://v3.football.api-sports.io';
          +  async function searchByTeam(teamName: string) {
          +    const url = `${base}/fixtures?date=${encodeURIComponent(date)}&search=${encodeURIComponent(teamName)}`;
          +    const res = await fetch(url, { headers: { 'x-rapidapi-key': apiKey, 'x-apisports-key': apiKey } });
          +    if (!res.ok) return [] as any[];
          +    const json = await res.json().catch(() => null);
          +    return (json?.response || []) as any[];
          +  }
          +
          +  // Keresés mindkét csapatnévre, majd metával pontosítunk
          +  const [hCand, aCand] = await Promise.all([searchByTeam(home), searchByTeam(away)]);
          +  const candidates = [...hCand, ...aCand];
          +
          +  // Pontos egyezés: ugyanaz a nap, egyező home/away (case-insensitive, trim)
          +  const norm = (s: string) => (s || '').trim().toLowerCase();
          +  const match = candidates.find((c: any) => {
          +    const f = c?.fixture; const t = c?.teams;
          +    if (!f || !t) return false;
          +    const d = (f.date || '').slice(0, 10);
          +    return d === date && (norm(t.home?.name) === norm(home) || norm(t.home?.name).includes(norm(home)))
          +                 && (norm(t.away?.name) === norm(away) || norm(t.away?.name).includes(norm(away)));
          +  });
          +  if (match?.fixture?.id) return { id: Number(match.fixture.id) };
          +  return null;
          +}

  - id: h2h_normalization
    description: "H2H evaluator – kis/nagybetű és Draw normalizálás, biztonságos összevetés"
    apply:
      - path: cloud_functions/src/evaluators/H2H.ts
        diff: |
          --- a/cloud_functions/src/evaluators/H2H.ts
          +++ b/cloud_functions/src/evaluators/H2H.ts
          @@
          -    const sel = (tip.selection || '').trim();
          -    const winner = (r.winner || '').trim();
          +    const norm = (s: string) => (s || '').trim().toLowerCase();
          +    const sel = norm(tip.selection);
          +    const winner = norm(r.winner || '');
          @@
          -      const { home, away } = r.scores;
          -      const computed = home > away ? (r.home_team || 'HOME')
          -        : away > home ? (r.away_team || 'AWAY')
          -        : 'Draw';
          -      return computed === sel ? 'won' : (computed === 'Draw' && sel === 'Draw' ? 'won' : 'lost');
          +      const { home, away } = r.scores;
          +      const compRaw = home > away ? (r.home_team || 'home')
          +        : away > home ? (r.away_team || 'away')
          +        : 'draw';
          +      const computed = norm(compRaw);
          +      if (computed === 'draw' && sel === 'draw') return 'won';
          +      return computed === sel ? 'won' : 'lost';

  - id: finalizer_multitip_void
    description: "match_finalizer – fixture feloldás tips[]-re, canceled→void, naplózás pontosítás"
    apply:
      - path: cloud_functions/src/match_finalizer.ts
        diff: |
          --- a/cloud_functions/src/match_finalizer.ts
          +++ b/cloud_functions/src/match_finalizer.ts
          @@
          -      // Gather unique eventIds from this batch's tips[] arrays
          -      const eventIdSet = new Set<string>();
          +      // Gather unique eventIds from this batch's tips[] arrays (multi-event tickets támogatás)
          +      const eventIdSet = new Set<string>();
           for (const doc of ticketsSnap.docs) {
             const tips = (doc.get('tips') as any[]) || [];
             for (const t of tips) {
               if (t && typeof t.eventId === 'string' && t.eventId.trim()) {
                 eventIdSet.add(t.eventId.trim());
               }
             }
           }
           const eventIds = Array.from(eventIdSet);
          -      logger.info('match_finalizer.unique_events_batch', { batch: batches, count: 
          +      logger.info('match_finalizer.unique_events_batch', { batch: batches, count: eventIds.length });
          @@
          -      // TODO: use provider to map eventIds→fixtureIds when needed
          +      // Fixture ID feloldás (ha a tipben nincs eltárolva)
          +      const fixtureMap: Record<string, number> = {};
          +      for (const doc of ticketsSnap.docs) {
          +        const tips = (doc.get('tips') as any[]) || [];
          +        for (const t of tips) {
          +          if (!t.fixtureId && t.eventName && t.startTime) {
          +            const found = await findFixtureIdByMeta({ eventName: t.eventName, startTime: t.startTime });
          +            if (found?.id) {
          +              fixtureMap[t.eventId] = found.id;
          +            }
          +          }
          +        }
          +      }
          @@
          -        // Normalize provider result → evaluator input
          +        // Normalize provider result → evaluator input; canceled = void
                   const results: Record<string, NormalizedResult> = {};
                   for (const [eid, r] of Object.entries(providerResults)) {
                     results[eid] = {
                       completed: !!r.completed,
                       scores: r.scores,
                       home_team: r.home_team,
                       away_team: r.away_team,
                       winner: r.winner,
                     };
                   }
          +        // canceled/void flag támogatása
          +        const voidSet = new Set<string>(Object.entries(providerResults)
          +          .filter(([_, r]: any) => r?.canceled === true || r?.status === 'canceled')
          +          .map(([eid]) => eid));
          @@
          -        const evaluated = tips.map((tip: any) => {
          +        const evaluated = tips.map((tip: any) => {
                       const market = String(tip.market || 'H2H');
                       const evaluator = getEvaluator(market);
                       const normRes = results[tip.eventId] || results[String(fixtureMap[tip.eventId] || '')];
          -            const result = evaluator ? evaluator.evaluate({ marketKey: market, selection: tip.selection, odds: tip.odds }, normRes) : 'pending';
          +            let result = evaluator ? evaluator.evaluate({ marketKey: market, selection: tip.selection, odds: tip.odds }, normRes) : 'pending';
          +            if (voidSet.has(tip.eventId)) result = 'void';
                       return { market, selection: tip.selection, result, oddsSnapshot: tip.odds };
                     });
          @@
          -        logger.info('match_finalizer.requeued', { nextAttempt: attempt + 1 });
          +        logger.warn('match_finalizer.requeued', { nextAttempt: attempt + 1, job });

# Vége
